import React, { useEffect, useState, useMemo } from "react";
import { database as db } from "./firebase-config";
import { ref, onValue } from "firebase/database";
import { Bar, Line } from "react-chartjs-2";
import "chart.js/auto";
import "chartjs-adapter-date-fns";

export default function Dashboard() {
  const [sites, setSites] = useState([]);
  const [alarms, setAlarms] = useState({});
  const [loading, setLoading] = useState(true);

  const [searchTerm, setSearchTerm] = useState("");
  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState("");
  const [showDownOnly, setShowDownOnly] = useState(false);
  const [debouncedShowDownOnly, setDebouncedShowDownOnly] = useState(showDownOnly);

  const [darkMode, setDarkMode] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);

  const itemsPerPage = 25;

  // --- Debounce searchTerm ---
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
      setCurrentPage(1);
    }, 300);
    return () => clearTimeout(handler);
  }, [searchTerm]);

  // --- Debounce showDownOnly ---
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedShowDownOnly(showDownOnly);
      setCurrentPage(1);
    }, 200);
    return () => clearTimeout(handler);
  }, [showDownOnly]);

  useEffect(() => {
    const sitesRef = ref(db, "geojson_sites");
    const alarmsRef = ref(db, "enodeb_alarms");

    onValue(sitesRef, (snapshot) => {
      if (snapshot.exists()) setSites(Object.values(snapshot.val()));
    });

    onValue(alarmsRef, (snapshot) => {
      if (snapshot.exists()) {
        setAlarms(snapshot.val());
        setLoading(false);
      }
    });
  }, []);

  // --- Combine sites with alarm status ---
  const sitesWithStatus = useMemo(() => {
    return sites.map((site) => {
      const alarm = Object.values(alarms).find((a) => a.eNodeB_Site_Code === site.awn_site_code);
      const isDown =
        alarm &&
        alarm.status !== "NORMAL" &&
        (!alarm.alarm_cleared || alarm.alarm_cleared === "");
      return { ...site, isDown, alarm };
    });
  }, [sites, alarms]);

  // --- Search index ---
  const sitesIndex = useMemo(() => {
    return sitesWithStatus.map((s) => ({
      ...s,
      searchKey: `${s.awn_site_code} ${s.province || ""} ${s.district || ""}`.toLowerCase(),
    }));
  }, [sitesWithStatus]);

  // --- Filtered Sites ---
  const filteredSites = useMemo(() => {
    let result = sitesIndex;
    if (debouncedShowDownOnly) result = result.filter((s) => s.isDown);
    if (debouncedSearchTerm.trim() !== "") {
      const lowerSearch = debouncedSearchTerm.toLowerCase();
      result = result.filter((s) => s.searchKey.includes(lowerSearch));
    }
    return result;
  }, [sitesIndex, debouncedSearchTerm, debouncedShowDownOnly]);

  // --- Pagination ---
  const totalPages = Math.ceil(filteredSites.length / itemsPerPage);
  const paginatedSites = useMemo(() => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    return filteredSites.slice(startIndex, startIndex + itemsPerPage);
  }, [filteredSites, currentPage]);

  const goToPrevPage = () => setCurrentPage((page) => Math.max(page - 1, 1));
  const goToNextPage = () => setCurrentPage((page) => Math.min(page + 1, totalPages));

  // --- Summary ---
  const totalSites = sitesWithStatus.length;
  const downSites = sitesWithStatus.filter((s) => s.isDown);
  const onlineSites = totalSites - downSites.length;

  // --- Chart: Down Sites by Province ---
  const downByProvince = useMemo(() => {
    const obj = {};
    downSites.forEach((s) => {
      obj[s.province] = (obj[s.province] || 0) + 1;
    });
    return obj;
  }, [downSites]);

  const chartData = {
    labels: Object.keys(downByProvince),
    datasets: [
      {
        label: "Sites Down",
        data: Object.values(downByProvince),
        backgroundColor: "rgba(255, 99, 132, 0.8)",
        borderColor: "rgba(255, 99, 132, 1)",
        borderWidth: 2,
      },
    ],
  };

  const chartOptions = {
    responsive: true,
    plugins: { legend: { labels: { color: darkMode ? "#eee" : "#333" } } },
  };

  // --- Time Series Chart ---
  const formatDate = (isoString) => {
    if (!isoString) return null;
    const d = new Date(isoString);
    if (isNaN(d)) return null;
    return d.toISOString().slice(0, 10);
  };

  const timeSeriesData = useMemo(() => {
    const occurredCountByDate = {};
    const clearedCountByDate = {};
    Object.values(alarms).forEach((alarm) => {
      const occurredDate = formatDate(alarm.alarm_occurred);
      if (occurredDate) occurredCountByDate[occurredDate] = (occurredCountByDate[occurredDate] || 0) + 1;
      const clearedDate = formatDate(alarm.alarm_cleared);
      if (clearedDate) clearedCountByDate[clearedDate] = (clearedCountByDate[clearedDate] || 0) + 1;
    });
    const allDates = Array.from(
      new Set([...Object.keys(occurredCountByDate), ...Object.keys(clearedCountByDate)])
    ).sort();
    return {
      labels: allDates,
      datasets: [
        {
          label: "Alarm Occurred",
          data: allDates.map((d) => occurredCountByDate[d] || 0),
          borderColor: "#f44336",
          backgroundColor: "rgba(244, 67, 54, 0.2)",
          fill: true,
          tension: 0.3,
        },
        {
          label: "Alarm Cleared",
          data: allDates.map((d) => clearedCountByDate[d] || 0),
          borderColor: "#4caf50",
          backgroundColor: "rgba(76, 175, 80, 0.2)",
          fill: true,
          tension: 0.3,
        },
      ],
    };
  }, [alarms]);

  const timeSeriesOptions = {
    responsive: true,
    interaction: { mode: "nearest", intersect: false },
    plugins: { legend: { labels: { color: darkMode ? "#eee" : "#333" } } },
    scales: {
      x: { type: "time", time: { unit: "day" }, ticks: { color: darkMode ? "#ccc" : "#444" } },
      y: { beginAtZero: true, ticks: { stepSize: 1, color: darkMode ? "#ccc" : "#444" } },
    },
  };

  const bgColor = darkMode ? "#121212" : "#f9f9f9";
  const textColor = darkMode ? "#eee" : "#222";
  const headerBg = darkMode ? "#274262" : "#ddd";
  const downBg = darkMode ? "#3a1f1f" : "#ffd6d6";
  const onlineBg = darkMode ? "#1b1b1b" : "#e6ffe6";
  const downColor = darkMode ? "#ff6b6b" : "#d10b0b";
  const onlineColor = darkMode ? "#75c575" : "#117a11";

  // --- Render ---
  return (
    <div style={{ padding: 24, maxWidth: 1100, margin: "auto", minHeight: "100vh", fontFamily: "Segoe UI, sans-serif", background: bgColor, color: textColor }}>
       <div style={{ textAlign: "center", marginBottom: 24 }}>
       <img src="/NT_Logo.svg.png" alt="Logo" style={{ maxWidth: 120, marginBottom: 10 }} />
      <h1 style={{ textAlign: "center", marginBottom: 24 }}>MNOC Alarm Monitoring Dashboard</h1>
      <div style={{ textAlign: "right", marginBottom: 16 }}>
        <label style={{ fontWeight: 600, cursor: "pointer" }}>
          <input type="checkbox" checked={darkMode} onChange={() => setDarkMode(!darkMode)} style={{ marginRight: 6 }} /> Dark Mode
        </label>
        </div>
      </div>

      <div style={{ display: "flex", gap: 24, flexWrap: "wrap", justifyContent: "center", marginBottom: 32 }}>
        <div style={{ flex: 1, minWidth: 200, padding: 28, borderRadius: 12, background: darkMode ? "#7b1a1a" : "#f8d7da", textAlign: "center" }}>
          <h2 style={{ margin: 0, fontSize: 22 }}>üî¥ Down Sites</h2>
          <p style={{ fontSize: 42, fontWeight: 700, marginTop: 12, color: downColor }}>{downSites.length}</p>
        </div>
        <div style={{ flex: 1, minWidth: 200, padding: 28, borderRadius: 12, background: darkMode ? "#1b4d1b" : "#d1e7dd", textAlign: "center" }}>
          <h2 style={{ margin: 0, fontSize: 22 }}>üü¢ Online Sites</h2>
          <p style={{ fontSize: 42, fontWeight: 700, marginTop: 12, color: onlineColor }}>{onlineSites}</p>
        </div>
      </div>

      <div style={{ display: "flex", gap: 12, flexWrap: "wrap", marginBottom: 20 }}>
        <div style={{ flex: "1 1 200px", display: "flex", alignItems: "center", gap: 8 }}>
          <label style={{ fontWeight: 600 }}>‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ Sites ‡∏ó‡∏µ‡πà Down:</label>
          <select value={showDownOnly ? "yes" : "no"} onChange={(e) => setShowDownOnly(e.target.value === "yes")} style={{ padding: "6px 12px", borderRadius: 6 }}>
            <option value="no">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
            <option value="yes">Down ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô</option>
          </select>
        </div>
        <div style={{ flex: "1 1 200px", display: "flex", alignItems: "center", gap: 8 }}>
          <label style={{ fontWeight: 600 }}>‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ Site:</label>
          <input type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å AWN Site, ‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î, ‡∏≠‡∏≥‡πÄ‡∏†‡∏≠" style={{ flex: 1, padding: "6px 12px", borderRadius: 6 }} />
        </div>
      </div>

      <div style={{ marginBottom: 40 }}>
        <h2 style={{ textAlign: "center" }}>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Sites Down ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î</h2>
        <Bar data={chartData} options={chartOptions} />
      </div>

      <div style={{ marginBottom: 40 }}>
        <h2 style={{ textAlign: "center" }}>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Alarm Occurred / Cleared (/day)</h2>
        <Line data={timeSeriesData} options={timeSeriesOptions} />
      </div>

      <div style={{ overflowX: "auto", borderRadius: 12 }}>
        <table style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead style={{ background: headerBg }}>
            <tr>
              <th>AWN Site Code</th>
              <th>Province</th>
              <th>District</th>
              <th>Status</th>
              <th>Alarm Name</th>
              <th>Occurred</th>
              <th>Cleared</th>
            </tr>
          </thead>
          <tbody>
            {paginatedSites.map((site, idx) => (
              <tr key={idx} style={{ background: site.isDown ? downBg : onlineBg, color: site.isDown ? downColor : onlineColor }}>
                <td>{site.awn_site_code}</td>
                <td>{site.province}</td>
                <td>{site.district}</td>
                <td>{site.isDown ? "Down" : "Online"}</td>
                <td>{site.alarm?.alarm_name || "-"}</td>
                <td>{site.alarm?.alarm_occurred || "-"}</td>
                <td>{site.alarm?.alarm_cleared || "-"}</td>
              </tr>
            ))}
            {paginatedSites.length === 0 && (
              <tr>
                <td colSpan="7" style={{ textAlign: "center", padding: 20 }}>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>

      <div style={{ marginTop: 20, display: "flex", justifyContent: "center", gap: 12, flexWrap: "wrap" }}>
        <button onClick={goToPrevPage} disabled={currentPage === 1}>‚óÄ ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤</button>
        <span style={{ alignSelf: "center", fontWeight: 600 }}>‡∏´‡∏ô‡πâ‡∏≤ {currentPage} / {totalPages || 1}</span>
        <button onClick={goToNextPage} disabled={currentPage === totalPages || totalPages === 0}>‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‚ñ∂</button>
      </div>
    </div>
  );
}
